// This file implements the IOleCommandTarget Interface and Gateway for Python.
// Generated by makegw.py

#include "axcontrol_pch.h"
#include "PyIOleCommandTarget.h"

// @doc - This file contains autoduck documentation
// ---------------------------------------------------
//
// Interface Implementation

PyIOleCommandTarget::PyIOleCommandTarget(IUnknown *pdisp):
	PyIUnknown(pdisp)
{
	ob_type = &type;
}

PyIOleCommandTarget::~PyIOleCommandTarget()
{
}

/* static */ IOleCommandTarget *PyIOleCommandTarget::GetI(PyObject *self)
{
	return (IOleCommandTarget *)PyIUnknown::GetI(self);
}

// @pymethod |PyIOleCommandTarget|QueryStatus|Description of QueryStatus.
PyObject *PyIOleCommandTarget::QueryStatus(PyObject *self, PyObject *args)
{
	PyObject *ret = NULL;
	PyObject *obGUID, *obCmds;
	IOleCommandTarget *pIOCT = GetI(self);
	OLECMD *pCmds = NULL;
	OLECMDTEXT *retText = NULL;
	if ( pIOCT == NULL )
		return NULL;
	if (!PyArg_ParseTuple(args, "OO", &obGUID, &obCmds))
		return NULL;

	GUID guid;
	GUID *pguid;
	if (obGUID == Py_None) {
		pguid = NULL;
	} else {
		if (!PyWinObject_AsIID(obGUID, &guid))
			return FALSE;
		pguid = &guid;
	}
	if (!PySequence_Check(obCmds))
		return PyErr_Format(PyExc_TypeError, "cmds must be a sequence");

	int ncmds = PySequence_Length(obCmds);
	int i;
	HRESULT hr;
	// From here, exit via 'goto done'
	const unsigned cbCmdText = 1024;
	retText = (OLECMDTEXT *)malloc(cbCmdText);
	if (!retText) {
		PyErr_NoMemory();
		goto done;
	}
	retText->cwBuf = (cbCmdText - sizeof(OLECMDTEXT)) / sizeof(WCHAR);

	pCmds = (OLECMD *)malloc(ncmds * sizeof(OLECMD));
	if (!pCmds) {
		PyErr_NoMemory();
		goto done;
	}
	for (i=0;i<ncmds;i++) {
		OLECMD *pThis = pCmds + i;
		PyObject *sub = PySequence_GetItem(obCmds, i);
		if (!sub)
			goto done;
		if (!PyArg_ParseTuple(sub, "ii",  &pThis->cmdID, &pThis->cmdf)) {
			PyErr_Format(PyExc_TypeError, "Element %d of command buffer was not a tuple of 2 integers", i);
			Py_DECREF(sub);
			goto done;
		}
		Py_DECREF(sub);
	}
	{ // scope to prevent goto warning.
	PY_INTERFACE_PRECALL;
	hr = pIOCT->QueryStatus( pguid, ncmds, pCmds, retText );
	PY_INTERFACE_POSTCALL;
	}

	if ( FAILED(hr) ) {
		PyCom_BuildPyException(hr, pIOCT, IID_IOleCommandTarget );
		goto done;
	}
	ret = Py_BuildValue("iN", retText->cmdtextf,
			    PyWinObject_FromWCHAR(retText->rgwz));
done:
	if (retText)
		free(retText);
	if (pCmds)
		free(pCmds);
	return ret;
}

// @pymethod |PyIOleCommandTarget|Exec|Description of Exec.
PyObject *PyIOleCommandTarget::Exec(PyObject *self, PyObject *args)
{
	PyObject *ret;
	int cmdid, cmdopt;
	PyObject *obVar;
	PyObject *obGUID;
	VARIANT varIn, varOut;
	IOleCommandTarget *pIOCT = GetI(self);
	if ( pIOCT == NULL )
		return NULL;
	if (!PyArg_ParseTuple(args, "OiiO", &obGUID, &cmdid, &cmdopt, &obVar))
		return NULL;

	GUID guid;
	GUID *pguid;
	if (obGUID == Py_None) {
		pguid = NULL;
	} else {
		if (!PyWinObject_AsIID(obGUID, &guid))
			return FALSE;
		pguid = &guid;
	}
	VariantInit(&varIn);
	VariantInit(&varOut);
	if (!PyCom_VariantFromPyObject(obVar, &varIn))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIOCT->Exec( pguid, cmdid, cmdopt, &varIn, &varOut);
	PY_INTERFACE_POSTCALL;
	
	VariantClear(&varIn);

	if ( FAILED(hr) ) {
		PyCom_BuildPyException(hr, pIOCT, IID_IOleCommandTarget );
		ret = NULL;
	} else {
		ret = PyCom_PyObjectFromVariant(&varOut);
	}
	VariantClear(&varOut);
	return ret;
}

// @object PyIOleCommandTarget|Description of the interface
static struct PyMethodDef PyIOleCommandTarget_methods[] =
{
	{ "QueryStatus", PyIOleCommandTarget::QueryStatus, 1 }, // @pymeth QueryStatus|Description of QueryStatus
	{ "Exec", PyIOleCommandTarget::Exec, 1 }, // @pymeth Exec|Description of Exec
	{ NULL }
};

PyComTypeObject PyIOleCommandTarget::type("PyIOleCommandTarget",
		&PyIUnknown::type,
		sizeof(PyIOleCommandTarget),
		PyIOleCommandTarget_methods,
		GET_PYCOM_CTOR(PyIOleCommandTarget));
// ---------------------------------------------------
//
// Gateway Implementation
STDMETHODIMP PyGOleCommandTarget::QueryStatus(
		/* [unique][in] */ const GUID * pguidCmdGroup,
		/* [in] */ ULONG cCmds,
		/* [out][in][size_is] */ OLECMD prgCmds[],
		/* [unique][out][in] */ OLECMDTEXT * pCmdText)
{
	PY_GATEWAY_METHOD;
	PyObject *obGUID;
	if (pguidCmdGroup == NULL) {
		obGUID = Py_None;
		Py_INCREF(obGUID);
	} else {
		obGUID = PyWinObject_FromIID(*pguidCmdGroup);
	}
	PyObject *cmds = PyList_New(cCmds);
	if (!cmds) {
		Py_DECREF(obGUID);
		MAKE_PYCOM_GATEWAY_FAILURE_CODE("QueryStatus");
	}
	for (ULONG i=0;i<cCmds;i++) {
		PyList_SET_ITEM(cmds, i,
				Py_BuildValue("ll", prgCmds[i].cmdID, prgCmds[i].cmdf));
	}
	PyObject *obTest = Py_None; // tbd
	PyObject *result;
	HRESULT hr=InvokeViaPolicy("QueryStatus", &result, "NNO", obGUID, cmds, obTest);
	if (FAILED(hr)) return hr;
	Py_DECREF(result);
	return hr;
}

STDMETHODIMP PyGOleCommandTarget::Exec(
		/* [unique][in] */ const GUID * pguidCmdGroup,
		/* [in] */ DWORD nCmdID,
		/* [in] */ DWORD nCmdexecopt,
		/* [unique][in] */ VARIANT * pvaIn,
		/* [unique][out][in] */ VARIANT * pvaOut)
{
	PY_GATEWAY_METHOD;
	PyObject *obGUID;
	if (pguidCmdGroup == NULL) {
		obGUID = Py_None;
		Py_INCREF(obGUID);
	} else {
		obGUID = PyWinObject_FromIID(*pguidCmdGroup);
	}
	PyObject *obpvaIn = PyCom_PyObjectFromVariant(pvaIn);
	PyObject *result;
	HRESULT hr=InvokeViaPolicy("Exec", &result, "NllN", obGUID, nCmdID, nCmdexecopt, obpvaIn);
	if (FAILED(hr)) return hr;
	hr = PyCom_VariantFromPyObject(result, pvaOut);
	Py_DECREF(result);
	return hr;
}


// This file implements the IPropertyStorage Interface and Gateway for Python.
// Generated by makegw.py

#include "stdafx.h"
#include "PythonCOM.h"

#ifndef NO_PYCOM_IPROPERTYSTORAGE
#include "PyIPropertyStorage.h"

// @doc - This file contains autoduck documentation
// ---------------------------------------------------

BOOL PyObject_AsPROPSPECs( PyObject *ob, PROPSPEC **ppRet, ULONG *pcRet)
{
	if (!PySequence_Check(ob)) {
		PyErr_SetString(PyExc_TypeError, "PROPSPECs must a sequence");
		return FALSE;
	}
	// First count the items, and the total string space we need.
	LONG cChars = 0;
	int len = PySequence_Length(ob);
	int i;
	for (i=0;i<len;i++) {
		PyObject *sub = PySequence_GetItem(ob, i);
		if (PyUnicode_Check(sub))
			cChars += PyUnicode_Size(sub) + 1;
		else if (PyString_Check(sub))
			cChars += PyString_Size(sub) + 1;
		else if (PyInt_Check(sub))
			;
		else {
			Py_DECREF(sub);
			PyErr_SetString(PyExc_TypeError, "PROPSPECs must be a sequence of strings or integers");
			return FALSE;
		}
		Py_DECREF(sub);
	}
	size_t numBytes = (sizeof(PROPSPEC) * len) + (sizeof(WCHAR) * cChars);
	PROPSPEC *pRet = (PROPSPEC *)malloc(numBytes);
	if (pRet==NULL) {
		PyErr_SetString(PyExc_MemoryError, "allocating PROPSPECs");
		return FALSE;
	}
	WCHAR *curBuf = (WCHAR *)(pRet+len);
	for (i=0;i<len;i++) {
		PyObject *sub = PySequence_GetItem(ob, i);
		BSTR bstr;
		if (PyWinObject_AsBstr(sub, &bstr)) {
			pRet[i].ulKind = PRSPEC_LPWSTR;
			pRet[i].lpwstr = curBuf;
			wcscpy( curBuf, bstr);
			curBuf += wcslen(curBuf) + 1;
		} else {
			PyErr_Clear();
			pRet[i].ulKind = PRSPEC_PROPID;
			pRet[i].propid = PyInt_AsLong(sub);
		}
		Py_DECREF(sub);
	}
	*ppRet = pRet;
	*pcRet = len;
	return TRUE;
}

void PyObject_FreePROPSPECs(PROPSPEC *pFree, ULONG /*cFree*/)
{
	free(pFree);
}

PyObject *PyObject_FromPROPVARIANT( PROPVARIANT *pVar )
{
	PyObject *ob;
	switch (pVar->vt) {
		case VT_EMPTY:
		case VT_NULL:
		case VT_ILLEGAL:
			Py_INCREF(Py_None);
			return Py_None;
		case VT_I1:
			return PyInt_FromLong(pVar->bVal);
		case VT_UI1:
			return PyInt_FromLong(pVar->bVal);
		case VT_I2:
			return PyInt_FromLong(pVar->iVal);
		case VT_UI2:
			return PyInt_FromLong(pVar->uiVal);
		case VT_I4:
			return PyInt_FromLong(pVar->lVal);
//		case VT_INT:
//			return PyInt_FromLong(pVar->intVal);
		case VT_UI4:
			return PyInt_FromLong(pVar->ulVal);
//		case VT_UINT:
//			return PyInt_FromLong(pVar->uintVal);
		case VT_I8:
			return PyWinObject_FromLARGE_INTEGER(pVar->hVal);
		case VT_UI8:
			return PyWinObject_FromULARGE_INTEGER(pVar->uhVal);
		case VT_R4:
			return PyFloat_FromDouble(pVar->fltVal);
		case VT_R8:
			return PyFloat_FromDouble(pVar->dblVal);
		case VT_CY:
			return PyObject_FromCurrency(pVar->cyVal);
		case VT_DATE:
			return PyWinObject_FromDATE(pVar->date);
		case VT_BSTR:
			return PyWinObject_FromBstr(pVar->bstrVal);
		case VT_BOOL:
			ob = pVar->boolVal ? Py_True : Py_False;
			Py_INCREF(ob);
			return ob;
		case VT_ERROR:
			return PyInt_FromLong(pVar->scode);
		case VT_FILETIME:
			return PyWinObject_FromFILETIME(pVar->filetime);
		case VT_LPSTR:
			if (pVar->pszVal == NULL) {
				Py_INCREF(Py_None);
				return Py_None;
			}
			return PyString_FromString(pVar->pszVal);
		case VT_LPWSTR:
			return PyWinObject_FromOLECHAR(pVar->pwszVal);
		case VT_CLSID:
			return PyWinObject_FromIID(*pVar->puuid);
		case VT_STREAM:
		case VT_STREAMED_OBJECT:
			return PyCom_PyObjectFromIUnknown(pVar->pStream, IID_IStream, TRUE);
		case VT_STORAGE:
		case VT_STORED_OBJECT:
			return PyCom_PyObjectFromIUnknown(pVar->pStorage, IID_IStorage, TRUE);
//		case VT_UNKNOWN:
//			return PyCom_PyObjectFromIUnknown(pVar->punkVal, IID_IUnknown, TRUE);
//		case VT_DISPATCH:
//			return PyCom_PyObjectFromIUnknown(pVar->pdispVal, IID_IDispatch, TRUE);

/*
// Want to get VT_CF and VT_BLOB working with a test case first!
		case VT_CF: { // special "clipboard format"
			// cbSize is the size of the buffer pointed to 
			// by pClipData, plus sizeof(ulClipFmt)
			// XXX - in that case, shouldn't we pass
			// pClipData + sizeof(DWORD) to Py_BuildValue??
			ULONG cb = CBPCLIPDATA(*pVar->pclipdata);
			return Py_BuildValue("is#",
			                     pVar->pclipdata->ulClipFmt,
			                     pVar->pclipdata->pClipData,
			                     (int)cb);
			}
		case VT_BLOB:
			// DWORD count of bytes, followed by that many bytes of data.
			// The byte count does not include the four bytes for the
			// length of the count itself; an empty blob member would
			// have a count of zero, followed by zero bytes.
			return PyString_FromStringAndSize((const char *)pVar->blob.pBlobData,
			                                  pVar->blob.cbSize);
*/
		default:
			PyErr_Format(PyExc_TypeError, "Unsupported property type 0x%x", pVar->vt);
			return NULL;
	}
}

PyObject *PyObject_FromPROPVARIANTs( PROPVARIANT *pVars, ULONG cVars )
{
	PyObject *ret = PyTuple_New(cVars);
	for (ULONG i=0;i<cVars;i++) {
		PyObject *sub = PyObject_FromPROPVARIANT(pVars+i);
		if (sub==NULL) {
			Py_DECREF(ret);
			return NULL;
		}
		PyTuple_SET_ITEM(ret, i, sub);
	}
	return ret;
}

BOOL PyObject_AsPROPVARIANT(PyObject *ob, PROPVARIANT *pVar)
{
	if (ob==Py_True) {
		pVar->boolVal = -1;
		pVar->vt = VT_BOOL;
	} else if (ob==Py_False) {
		pVar->boolVal = 0;
		pVar->vt = VT_BOOL;
	} else if (PyInt_Check(ob)) {
		pVar->lVal = PyInt_AsLong(ob);
		pVar->vt = VT_I4;
	} else if (PyFloat_Check(ob)) {
		pVar->dblVal = PyFloat_AsDouble(ob);
		pVar->vt = VT_R8;
	} else if (PyUnicode_Check(ob) || PyString_Check(ob)) {
		PyWinObject_AsBstr(ob, &pVar->bstrVal);
		pVar->vt = VT_BSTR;
	} else {
		PyErr_SetString(PyExc_TypeError, "Unsupported object for PROPVARIANT");
		return FALSE;
	}
	return TRUE;
}

BOOL PyObject_AsPROPVARIANTs(PyObject *ob, PROPVARIANT **ppRet, ULONG *pcRet)
{
	if (!PySequence_Check(ob)) {
		PyErr_SetString(PyExc_TypeError, "PROPVARIANTs must a sequence");
		return FALSE;
	}
	int len = PySequence_Length(ob);

	PROPVARIANT *pRet = new PROPVARIANT[len];
	int i;
	for (i=0;i<len;i++)
		PropVariantInit(pRet+i);

	for (i=0;i<len;i++) {
		PyObject *sub = PySequence_GetItem(ob, i);
		BOOL ok = PyObject_AsPROPVARIANT(sub, pRet+i);
		Py_DECREF(sub);
		if (!ok) {
			for (int j=0;j<i;j++)
				PropVariantClear(pRet+j);
			delete [] pRet;
			return FALSE;
		}
	}
	*ppRet = pRet;
	*pcRet = len;
	return TRUE;
}

void PyObject_FreePROPVARIANTs(PROPVARIANT *pVars, ULONG cVars)
{
	for (ULONG i=0;i<cVars;i++)
		PropVariantClear(pVars+i);
	delete [] pVars;
}

BOOL PyObject_AsPROPIDs(PyObject *ob, PROPID **ppRet, ULONG *pcRet)
{
	if (!PySequence_Check(ob)) {
		PyErr_SetString(PyExc_TypeError, "PROPIDs must a sequence");
		return FALSE;
	}
	int len = PySequence_Length(ob);

	PROPID *pRet = new PROPID[len];
	BOOL ok = TRUE;
	for (int i=0;ok && i<len;i++) {
		PyObject *sub = PySequence_GetItem(ob, i);
		ok = PyInt_Check(sub);
		if (!ok )
			PyErr_SetString(PyExc_TypeError, "Must be array of ints");
		if (ok)
			pRet[i] = PyInt_AsLong(sub);
		Py_XDECREF(sub);
	}
	if (!ok) {
		delete [] pRet;
		return FALSE;
	}
	*ppRet = pRet;
	*pcRet = len;
	return TRUE;
}
void PyObject_FreePROPIDs(PROPID *pFree, ULONG)
{
	delete [] pFree;
}

//
// Interface Implementation

PyIPropertyStorage::PyIPropertyStorage(IUnknown *pdisp):
	PyIUnknown(pdisp)
{
	ob_type = &type;
}

PyIPropertyStorage::~PyIPropertyStorage()
{
}

/* static */ IPropertyStorage *PyIPropertyStorage::GetI(PyObject *self)
{
	return (IPropertyStorage *)PyIUnknown::GetI(self);
}

// @pymethod |PyIPropertyStorage|ReadMultiple|Reads specified properties from the current property set.
PyObject *PyIPropertyStorage::ReadMultiple(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	PyObject *props;
	// @pyparm (<o PROPSPEC>, ...)|props||The property IDs.
	if ( !PyArg_ParseTuple(args, "O:ReadMultiple", &props))
		return NULL;
	ULONG cProps;
	PROPSPEC *pProps;
	if (!PyObject_AsPROPSPECs( props, &pProps, &cProps))
		return NULL;
	PROPVARIANT *pPropVars = new PROPVARIANT[cProps];
	if (pPropVars==NULL) {
		PyObject_FreePROPSPECs(pProps, cProps);
		PyErr_SetString(PyExc_MemoryError, "allocating PROPVARIANTs");
		return NULL;
	}
	ULONG i;
	for (i=0;i<cProps;i++)
		PropVariantInit(pPropVars+i);

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->ReadMultiple( cProps, pProps, pPropVars );
	PY_INTERFACE_POSTCALL;

	PyObject *rc;
	if ( FAILED(hr) )
		rc = PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	else
		rc = PyObject_FromPROPVARIANTs(pPropVars, cProps);

	// Cleanup the property IDs.
	PyObject_FreePROPSPECs( pProps, cProps );
	// Cleanup the prop variants.
	for (i=0;i<cProps;i++) {
		PropVariantClear(pPropVars+i);
	}
	delete [] pPropVars;
	return rc;
}

// @pymethod |PyIPropertyStorage|WriteMultiple|Description of WriteMultiple.
PyObject *PyIPropertyStorage::WriteMultiple(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	PyObject *obProps;
	PyObject *obValues;
	long minId = 2;
	// @pyparm (<o PROPSPEC>, ...)|props||The property IDs.
	// @pyparm (<o PROPVARIANT>, ...)|values||The values for the properties.
	if ( !PyArg_ParseTuple(args, "OO|l:WriteMultiple", &obProps, &obValues, &minId))
		return NULL;

	PROPSPEC *pProps;
	ULONG cProps;
	if (!PyObject_AsPROPSPECs( obProps, &pProps, &cProps))
		return NULL;

	PROPVARIANT *pVals;
	ULONG cVals;
	if (!PyObject_AsPROPVARIANTs( obValues, &pVals, &cVals ))
		return NULL;

	if (cProps != cVals) {
		PyErr_SetString(PyExc_ValueError, "The parameters must be sequences of the same size");
		PyObject_FreePROPSPECs(pProps, cProps);
		PyObject_FreePROPVARIANTs(pVals, cVals);
		return NULL;
	}

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->WriteMultiple( cProps, pProps, pVals, minId );
	PY_INTERFACE_POSTCALL;

	PyObject_FreePROPSPECs(pProps, cProps);
	PyObject_FreePROPVARIANTs(pVals, cVals);

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIPropertyStorage|DeleteMultiple|Description of DeleteMultiple.
PyObject *PyIPropertyStorage::DeleteMultiple(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;

	PyObject *props;
	// @pyparm (<o PROPSPEC>, ...)|props||The property IDs.
	if ( !PyArg_ParseTuple(args, "O:ReadMultiple", &props))
		return NULL;
	ULONG cProps;
	PROPSPEC *pProps;
	if (!PyObject_AsPROPSPECs( props, &pProps, &cProps))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->DeleteMultiple( cProps, pProps );
	PY_INTERFACE_POSTCALL;

	PyObject_FreePROPSPECs(pProps, cProps);

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIPropertyStorage|ReadPropertyNames|Retrieves any existing string names for the specified property identifiers.
PyObject *PyIPropertyStorage::ReadPropertyNames(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	PyObject *obProps;
	// @pyparm (<o PROPSPEC>, ...)|props||The property IDs.
	if ( !PyArg_ParseTuple(args, "O:ReadPropertyNames", &obProps))
		return NULL;

	ULONG cProps;
	PROPID *pProps;
	if (!PyObject_AsPROPIDs( obProps, &pProps, &cProps))
		return NULL;

	HRESULT hr;
	LPWSTR *ppStrs = new LPWSTR[cProps];
	memset(ppStrs, 0, sizeof(LPWSTR)*cProps);
	PY_INTERFACE_PRECALL;
	hr = pIPS->ReadPropertyNames( cProps, pProps, ppStrs );
	PY_INTERFACE_POSTCALL;

	PyObject *rc;
	if ( FAILED(hr) )
		rc = PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	else {
		rc = PyTuple_New(cProps);
		for (ULONG i=0;i<cProps;i++)
			PyTuple_SET_ITEM( rc, i, PyWinObject_FromOLECHAR(ppStrs[i]) );
	}
	for (ULONG i=0;i<cProps;i++)
		if (ppStrs[i]) CoTaskMemFree(ppStrs[i]);
	delete [] ppStrs;
	PyObject_FreePROPIDs(pProps, cProps);
	return rc;
}

// @pymethod |PyIPropertyStorage|WritePropertyNames|Assigns string names to a specified array of property IDs in the current property set.
PyObject *PyIPropertyStorage::WritePropertyNames(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	PyObject *obProps;
	PyObject *obNames;
	// @pyparm (<o PROPSPEC>, ...)|props||The property IDs.
	// @pyparm (string, ...)|names||The property names.
	if ( !PyArg_ParseTuple(args, "OO:WritePropertyNames", &obProps, &obNames))
		return NULL;

	ULONG cProps = 0;
	PROPID *pProps = NULL;
	LPWSTR *ppStrs = NULL;
	PyObject *rc = NULL;

	if (!PyObject_AsPROPIDs( obProps, &pProps, &cProps))
		return NULL;

	if (!PySequence_Check(obNames) || PySequence_Length(obNames) != (int)cProps) {
		PyErr_SetString(PyExc_TypeError, "property named must be a sequence the same size as PROPDESCs");
		return NULL;
	}
	HRESULT hr;
	ppStrs = new LPWSTR[cProps];
	memset(ppStrs, 0, sizeof(LPWSTR)*cProps);
	ULONG i;
	for (i=0;i<cProps;i++) {
		PyObject *sub = PySequence_GetItem(obNames, i);
		BOOL ok = PyWinObject_AsBstr(sub, ppStrs+i);
		Py_XDECREF(sub);
		if (!ok)
			goto done;
	}
	{
	PY_INTERFACE_PRECALL;
	hr = pIPS->WritePropertyNames( cProps, pProps, ppStrs );
	PY_INTERFACE_POSTCALL;
	}

	if ( FAILED(hr) )
		rc = PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	else {
		rc = PyTuple_New(cProps);
		for (ULONG i=0;i<cProps;i++)
			PyTuple_SET_ITEM( rc, i, PyWinObject_FromOLECHAR(ppStrs[i]) );
	}
done:
	if (pProps)
		PyObject_FreePROPIDs(pProps, cProps);
	if (ppStrs) {
		for (i=0;i<cProps;i++) {
			PyWinObject_FreeBstr(ppStrs[i]);
		}
		delete [] ppStrs;
	}
	return rc;
}

// @pymethod |PyIPropertyStorage|DeletePropertyNames|Description of DeletePropertyNames.
PyObject *PyIPropertyStorage::DeletePropertyNames(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	PyObject *obProps;
	// @pyparm (<o PROPSPEC>, ...)|props||The property IDs.
	if ( !PyArg_ParseTuple(args, "O:DeletePropertyNames", &obProps))
		return NULL;

	ULONG cProps;
	PROPID *pProps;
	if (!PyObject_AsPROPIDs( obProps, &pProps, &cProps))
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->DeletePropertyNames( cProps, pProps );
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIPropertyStorage|Commit|Description of Commit.
PyObject *PyIPropertyStorage::Commit(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	// @pyparm int|grfCommitFlags||Description for grfCommitFlags
	DWORD grfCommitFlags;
	if ( !PyArg_ParseTuple(args, "l:Commit", &grfCommitFlags) )
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->Commit( grfCommitFlags );
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIPropertyStorage|Revert|Description of Revert.
PyObject *PyIPropertyStorage::Revert(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	if ( !PyArg_ParseTuple(args, ":Revert") )
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->Revert( );
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIPropertyStorage|Enum|Description of Enum.
PyObject *PyIPropertyStorage::Enum(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	IEnumSTATPROPSTG * ppenum;
	if ( !PyArg_ParseTuple(args, ":Enum") )
		return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->Enum( &ppenum );
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	PyObject *obppenum;

	obppenum = PyCom_PyObjectFromIUnknown(ppenum, IID_IEnumSTATPROPSTG, FALSE);
	PyObject *pyretval = Py_BuildValue("O", obppenum);
	Py_XDECREF(obppenum);
	return pyretval;
}

// @pymethod |PyIPropertyStorage|SetTimes|Description of SetTimes.
PyObject *PyIPropertyStorage::SetTimes(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	// @pyparm <o PyTime>|pctime||Description for pctime
	// @pyparm <o PyTime>|patime||Description for patime
	// @pyparm <o PyTime>|pmtime||Description for pmtime
	PyObject *obpctime;
	PyObject *obpatime;
	PyObject *obpmtime;
	FILETIME pctime;
	FILETIME patime;
	FILETIME pmtime;
	if ( !PyArg_ParseTuple(args, "OOO:SetTimes", &obpctime, &obpatime, &obpmtime) )
		return NULL;
	BOOL bPythonIsHappy = TRUE;
	if (!PyWinObject_AsFILETIME(obpctime, &pctime))
		return NULL;
	if (!PyWinObject_AsFILETIME(obpatime, &patime))
		return NULL;
	if (!PyWinObject_AsFILETIME(obpmtime, &pmtime))
		return NULL;

	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->SetTimes( &pctime, &patime, &pmtime );
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIPropertyStorage|SetClass|Description of SetClass.
PyObject *PyIPropertyStorage::SetClass(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	// @pyparm <o PyIID>|clsid||Description for clsid
	PyObject *obclsid;
	IID clsid;
	if ( !PyArg_ParseTuple(args, "O:SetClass", &obclsid) )
		return NULL;
	BOOL bPythonIsHappy = TRUE;
	if (!PyWinObject_AsIID(obclsid, &clsid)) bPythonIsHappy = FALSE;
	if (!bPythonIsHappy) return NULL;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->SetClass( clsid );
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	Py_INCREF(Py_None);
	return Py_None;

}

// @pymethod |PyIPropertyStorage|Stat|Description of Stat.
PyObject *PyIPropertyStorage::Stat(PyObject *self, PyObject *args)
{
	IPropertyStorage *pIPS = GetI(self);
	if ( pIPS == NULL )
		return NULL;
	if ( !PyArg_ParseTuple(args, ":Stat") )
		return NULL;
	STATPROPSETSTG p;
	HRESULT hr;
	PY_INTERFACE_PRECALL;
	hr = pIPS->Stat( &p );
	PY_INTERFACE_POSTCALL;

	if ( FAILED(hr) )
		return PyCom_BuildPyException(hr, pIPS, IID_IPropertyStorage);
	return PyCom_PyObjectFromSTATPROPSETSTG(&p);
}

// @object PyIPropertyStorage|Description of the interface
static struct PyMethodDef PyIPropertyStorage_methods[] =
{
	{ "ReadMultiple", PyIPropertyStorage::ReadMultiple, 1 }, // @pymeth ReadMultiple|Reads specified properties from the current property set.
	{ "WriteMultiple", PyIPropertyStorage::WriteMultiple, 1 }, // @pymeth WriteMultiple|Description of WriteMultiple
	{ "DeleteMultiple", PyIPropertyStorage::DeleteMultiple, 1 }, // @pymeth DeleteMultiple|Description of DeleteMultiple
	{ "ReadPropertyNames", PyIPropertyStorage::ReadPropertyNames, 1 }, // @pymeth ReadPropertyNames|Retrieves any existing string names for the specified property identifiers.
	{ "WritePropertyNames", PyIPropertyStorage::WritePropertyNames, 1 }, // @pymeth WritePropertyNames|Assigns string names to a specified array of property IDs in the current property set.
	{ "DeletePropertyNames", PyIPropertyStorage::DeletePropertyNames, 1 }, // @pymeth DeletePropertyNames|Description of DeletePropertyNames
	{ "Commit", PyIPropertyStorage::Commit, 1 }, // @pymeth Commit|Description of Commit
	{ "Revert", PyIPropertyStorage::Revert, 1 }, // @pymeth Revert|Description of Revert
	{ "Enum", PyIPropertyStorage::Enum, 1 }, // @pymeth Enum|Description of Enum
	{ "SetTimes", PyIPropertyStorage::SetTimes, 1 }, // @pymeth SetTimes|Description of SetTimes
	{ "SetClass", PyIPropertyStorage::SetClass, 1 }, // @pymeth SetClass|Description of SetClass
	{ "Stat", PyIPropertyStorage::Stat, 1 }, // @pymeth Stat|Description of Stat
	{ NULL }
};

PyComEnumProviderTypeObject PyIPropertyStorage::type("PyIPropertyStorage",
		&PyIUnknown::type,
		sizeof(PyIPropertyStorage),
		PyIPropertyStorage_methods,
		GET_PYCOM_CTOR(PyIPropertyStorage),
		"Enum");

#endif // NO_PYCOM_IPROPERTYSTORAGE
